set -x
# Script for removing shared mem, sdemaphores, and message queues.
# To be used on redundant server processes when an mfds kill has occurred.
#
# Info.....
#
#     Written by.......... Luke Bowman (LB)
#     Date of creation.... 30th January 2006.   
#
#     UPDATE HISTORY
#
#        VERSION   DATE      WHO   REASON
#        1.0       30JAN2006 LB    Initial Release
#                                  Was using -S $procid to remove semaphores
#                                  which worked on Linux but on AIX does not.
#                                  Changed to search for the translated hex 
#                                  for the procid and awk for the related semid.
#                                  UnixWare has a different format for ps which 
#                                  throws out my use of proc_name
#                                  Linux has a totally different format for 
#                                  ps which had to be catered for.
#        1.1      10FEB2006 LB     casmgr_flag used instead of awk on ps output.
#        1.2      09MAR2006 STMK   Version number added.
#        1.3      10MAR2006 LB     Revised annotation.                         
#        1.4      20MAR2006 LB     mfmemqlist added to remove message queues   
#        1.5      28MAR2006 LB     mfmemqlist trigger created for so that
#                                  COBOL int can be located on PATH.
#                                  (location of mfmem* files must be added to
#                                   PATH if used outside of Micro Focus T3
#                                   test system).
#        1.6       03MAY2006 LB    asroot removed for external use.
#        1.6.5     11MAY2006 LB    mfmemqlist40 added to to support products 
#                                  pre-5.0 products, which use a different 
#                                  sized CFG-AREA.
#        1.7       12MAY2006 LB    Processes are searched for using grep for 
#                                  server name in ps, which means embeded 
#                                  names would all be identified and removed. 
#                                  (e.g. mfmemclean ESDEMO would also locate 
#                                  and remove ESDEMO2 TMPESDEMO and NEWESDEMO5).
#                                  All ps strings using serv_name start /r 
#                                  and end in a space, so grep changed to use 
#                                  grep -w r$serv_name when creating the 
#                                  search list, so / and " " denote ends.
#                                  Version also brought in line with CVS
#                                  version.
#
#     @(#)mfmemclean      1.7 - Last Updated 12th May 2006.
#
# Function ...
#
# Script will accept the name of a redundant Service from the command line 
# kill each cas process related to that service, then search and destroy all 
# semaphores and shared memory allocated for that service.
# 
# This should be used when cleaning up after a kill of mfds has been done 
# without shutting down all services cleanly first.
#
# As this is a tool for recoving a system already in a bad state, none 
# of the ipcrm or kill output is validated. To debug remove "> /dev/null"
#
# Instructions...
# mfmemclean {Servicename}
# mfmemclean ESDEMO
#

usage_loop()
{

echo "Usage :  mfmemclean {Server name}"
exit 

}

not_found_loop()
{

echo "Server name "$serv_name" not found."
exit 

}

kill_proc_loop()
{
## *** REMOVED 1.1 (10FEB2006) ***
##
## 1.1 (10FEB2006)
## This section of code became difficult to maintain using awk to find the 
## CAS process name as some machines had a date format "mmm dd" if the 
## service was started > 24 hours ago and some had hh:mm:ss if it was 
## started < 24 hours ago. So I now just grep for casmgr and set a flag.
##
## Save the name of the process which is last in the list for all 
## process inclding the string $server_name, to use later.
##
##if (test `uname -s` = "UnixWare")
##     proc_name=`COLUMNS=160 ps -fu$LOGNAME |  fgrep $serv_name |  fgrep -v grep|  fgrep -v awk |  fgrep -v mfmemclean | awk '{print $10}' | head -1`
##else 
##     proc_name=`COLUMNS=160 ps -fu$LOGNAME |  fgrep $serv_name |  fgrep -v grep|  fgrep -v awk |  fgrep -v mfmemclean | awk '{print $8}' | head -1`
##fi
## *** REMOVED 1.1 (10FEB2006) ***
##

##
## *** ADDED 1.1 (10FEB2006) ***
COLUMNS=160 ps -fu$LOGNAME |  fgrep $serv_name |  fgrep -v grep|  fgrep -v awk |  fgrep -v mfmemclean | head -1 | grep casmgr > /dev/null
##
## If the process is casmgr we need to remove the shared mem first, so set the 
## flag to yes. Otherwise we only need to remove a semaphore.
##
if (test $? = "0") then
    casmgr_flag=yes
else 
    casmgr_flag=no
fi
##
## Save the process id of the process which is last in the list for all 
## $server_name process.
##
procpid=`COLUMNS=160 ps -fu$LOGNAME |  fgrep $serv_name |  fgrep -v grep |  fgrep -v awk |  fgrep -v mfmemclean | awk '{print $2}' | head -1 `
## *** ADDED 1.1 (10FEB2006) ***
##

##
## convert process id to hex, to use in search for hex key in ipcs.
##
hexpid=`echo ""$procpid" "16" o p" | dc`

##
## Some machines use lowercase for hex key so test for upper and lower.
##
lowhexpid=`echo $hexpid | tr [A-Z] [a-z]`

##
## First kill the process.
##

kill -9 $procpid > /dev/null

##
## If the casmgr flag is set remove the shared mem first then the semaphore.
##
if (test $casmgr_flag = "yes") then
    ##
    ## Find the hex value for the process id from the shared mem list.
    ##
    ipcs -m | grep $hexpid   > /dev/null
    if (test $? != "0") then
       ipcstmp=`ipcs -m | grep $lowhexpid  ` 
    else 
       ipcstmp=`ipcs -m | grep $hexpid ` 
    fi
    ##
    ## Some OS's allow big semids that concatanate with column 1 in ipcs
    ## so we check for a space at the 2nd char position in the string before 
    ## extracting the shared mem id.
    ## Also use same rule for Linux which has a different format for ipcs
    ##
    ipcsline=`echo $ipcstmp | cut -c2`
    if (test "$ipcsline.x" = " .x" -o `uname -s` = "Linux" ) then
          ipcspid=`echo $ipcstmp | awk '{print $2}' `
       else 
          ipcspid=`echo  $ipcstmp | awk '{print $1}'| sed -e 's/^m//' `
    fi

    ipcrm -m $ipcspid > /dev/null
fi

## 
## Now search and remove a semaphore array.
##
ipcs -s | grep $hexpid  > /dev/null
if (test $? != "0") then
   ipcstmp=`ipcs -s | grep $lowhexpid ` 2> /dev/null
else 
   ipcstmp=`ipcs -s | grep $hexpid ` 2> /dev/null
fi
##
## Some OS's allow big semids that concatanate with column 1 in ipcs
## so we check for a space at the 2nd char position in the string before 
## extracting the shared mem id.
## Also use same rule for Linux which has a different format for ipcs
##
ipcsline=`echo $ipcstmp | cut -c2`
if (test "$ipcsline.x" = " .x" -o `uname -s` = "Linux" ) then
   ipcspid=`echo $ipcstmp | awk '{print $2}' ` 2> /dev/null
else 
   ipcspid=`echo  $ipcstmp | awk '{print $1}'| sed -e 's/^s//' ` 2> /dev/null
fi

ipcrm -s $ipcspid > /dev/null

}

proc_queue_loop()
{

## 
## Now search and remove the message queue.
##

##
## Run mfmemqlist COBOL program to extract the id of the message queue 
## 

case $COBDIR.x in
        .x)  echo "Warning : Unable to search for message queues as COBDIR is not set to a valid "
             echo "COBOL product. Please ensure you environment is correctly configured and re-try." ;;
         *) prod_ver=`cat $COBDIR/etc/cobver |grep PRN | cut -c 21-22`
               if (test $prod_ver = "40") then
               memq_num=`TXDIR=$COBDIR mfmemqlist40 $serv_name`
            else
               memq_num=`TXDIR=$COBDIR mfmemqlist $serv_name`
            fi                      ;;
esac


##
## convert process id to hex, to use in search for hex key in ipcs.
##
hexpid=`echo ""$memq_num" "16" o p" | dc`

##
## Some machines use lowercase for hex key so test for upper and lower.
##
lowhexpid=`echo $hexpid | tr [A-Z] [a-z]`

##
## Test that the message queue id exists then remove it.
##

que_process_id=`ipcs -q |grep $lowhexpid`
    ipcs -q | grep $lowhexpid   > /dev/null
    if (test $? != "0") then
       echo "Warning : message queue for server " $serv_name " not found, expected id : " $lowhexpid
       else
       ipcstmp=`ipcs -q | grep $lowhexpid  `
       ##
       ## Some OS's allow big queue ids that concatanate with column 1 in ipcs
       ## so we check for a space at the 2nd char position in the string before
       ## extracting the queue id.
       ## Also use same rule for Linux which has a different format for ipcs
       ##
       ipcsline=`echo $ipcstmp | cut -c2`
       if (test "$ipcsline.x" = " .x" -o `uname -s` = "Linux" ) then
             ipcspid=`echo $ipcstmp | awk '{print $2}' `
          else
             ipcspid=`echo $ipcstmp | awk '{print $1}'| sed -e 's/^m//' `
       fi
       ipcrm -q $ipcspid > /dev/null
    fi

}

######################
## MFMEMCLEAN START ##
######################

##
## Initialise flags and variables.
##
serv_name=$1
found_end=0
casmgr_flag=no

##
## Server name validation section.                                 
## If invalid server name exit with usage or not found message.
##

##
## Checks that a command line has been passed.
##
if (test $serv_name.x = ".x") then
    usage_loop 
else 
    ##
    ## Check that a valid server name has been passed.
    ##
    COLUMNS=160 ps -fu$LOGNAME |  grep -w r$serv_name | fgrep -v grep |  fgrep -v mfmemclean > /dev/null
    if (test $? != "0" ) then
        not_found_loop
    else
       ##
       ## Kill cascd first to stop re-creation of cassi32.
       ##
       procpid=`COLUMNS=160 ps -fu$LOGNAME |  grep -w r$serv_name |  fgrep cascd |  fgrep -v grep |  fgrep -v awk |  fgrep -v mfmemclean | awk '{print $2}' | head -1 `
       kill -9 $procpid > /dev/null
    fi
fi

##
## We should have a verified valid server name at this point, $serv_name
## This will work through the list of CAS process, searching 
## for "r$serv_name ", where "r" is used to denote the startof the server 
## name in the ps list and -w forces " " to denote the end of the server name.
## Using this list the script remvoves memory, semaphores, plus the 
## process itself, until none are left.
##

##
### Loop until no $serv_name processes are found
##
while true
do
    COLUMNS=160 ps -fu$LOGNAME |  grep -w r$serv_name | fgrep -v grep |  fgrep -v mfmemclean > /dev/null
    if (test $? = "0")then
       kill_proc_loop
    else
       found_end=1
    fi
    ##
    ## When no more process are left for the server, remove msg queue then exit.
    ##
    if [ "$found_end.x" = "1.x" ]
    then
       proc_queue_loop
       break
    fi
done

######################
##  MFMEMCLEAN END  ##
######################
